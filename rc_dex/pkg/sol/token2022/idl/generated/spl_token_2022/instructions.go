// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.

package spl_token2022

import (
	"bytes"
	"fmt"
	ag_spew "github.com/davecgh/go-spew/spew"
	ag_binary "github.com/gagliardetto/binary"
	ag_solanago "github.com/gagliardetto/solana-go"
	ag_text "github.com/gagliardetto/solana-go/text"
	ag_treeout "github.com/gagliardetto/treeout"
)

var ProgramID ag_solanago.PublicKey

func SetProgramID(pubkey ag_solanago.PublicKey) {
	ProgramID = pubkey
	ag_solanago.RegisterInstructionDecoder(ProgramID, registryDecodeInstruction)
}

const ProgramName = "SplToken2022"

func init() {
	if !ProgramID.IsZero() {
		ag_solanago.RegisterInstructionDecoder(ProgramID, registryDecodeInstruction)
	}
}

var (
	Instruction_InitializeMint = ag_binary.TypeID([8]byte{209, 42, 195, 4, 129, 85, 209, 44})

	Instruction_InitializeAccount = ag_binary.TypeID([8]byte{74, 115, 99, 93, 197, 69, 103, 7})

	Instruction_InitializeMultisig = ag_binary.TypeID([8]byte{220, 130, 117, 21, 27, 227, 78, 213})

	Instruction_Transfer = ag_binary.TypeID([8]byte{163, 52, 200, 231, 140, 3, 69, 186})

	Instruction_Approve = ag_binary.TypeID([8]byte{69, 74, 217, 36, 115, 117, 97, 76})

	Instruction_Revoke = ag_binary.TypeID([8]byte{170, 23, 31, 34, 133, 173, 93, 242})

	Instruction_SetAuthority = ag_binary.TypeID([8]byte{133, 250, 37, 21, 110, 163, 26, 121})

	Instruction_MintTo = ag_binary.TypeID([8]byte{241, 34, 48, 186, 37, 179, 123, 192})

	Instruction_Burn = ag_binary.TypeID([8]byte{116, 110, 29, 56, 107, 219, 42, 93})

	Instruction_CloseAccount = ag_binary.TypeID([8]byte{125, 255, 149, 14, 110, 34, 72, 24})

	Instruction_FreezeAccount = ag_binary.TypeID([8]byte{253, 75, 82, 133, 167, 238, 43, 130})

	Instruction_ThawAccount = ag_binary.TypeID([8]byte{115, 152, 79, 213, 213, 169, 184, 35})

	Instruction_TransferChecked = ag_binary.TypeID([8]byte{119, 250, 202, 24, 253, 135, 244, 121})

	Instruction_ApproveChecked = ag_binary.TypeID([8]byte{47, 197, 254, 42, 58, 201, 58, 109})

	Instruction_MintToChecked = ag_binary.TypeID([8]byte{229, 236, 36, 240, 118, 225, 45, 125})

	Instruction_BurnChecked = ag_binary.TypeID([8]byte{198, 121, 200, 102, 120, 208, 155, 178})

	Instruction_InitializeAccount2 = ag_binary.TypeID([8]byte{8, 182, 149, 144, 185, 31, 209, 105})

	Instruction_SyncNative = ag_binary.TypeID([8]byte{155, 219, 36, 36, 239, 128, 21, 65})

	Instruction_InitializeAccount3 = ag_binary.TypeID([8]byte{23, 142, 140, 135, 21, 160, 133, 64})

	Instruction_InitializeMultisig2 = ag_binary.TypeID([8]byte{81, 239, 73, 39, 27, 148, 2, 146})

	Instruction_InitializeMint2 = ag_binary.TypeID([8]byte{95, 108, 198, 210, 72, 243, 143, 235})

	Instruction_GetAccountDataSize = ag_binary.TypeID([8]byte{16, 177, 210, 128, 21, 45, 111, 31})

	Instruction_InitializeImmutableOwner = ag_binary.TypeID([8]byte{141, 50, 15, 44, 195, 247, 34, 60})

	Instruction_AmountToUiAmount = ag_binary.TypeID([8]byte{160, 145, 200, 98, 242, 156, 30, 90})

	Instruction_UiAmountToAmount = ag_binary.TypeID([8]byte{173, 243, 64, 4, 103, 31, 56, 52})

	Instruction_InitializeMintCloseAuthority = ag_binary.TypeID([8]byte{117, 167, 56, 158, 201, 160, 209, 109})

	Instruction_Reallocate = ag_binary.TypeID([8]byte{79, 177, 5, 90, 135, 125, 234, 85})

	Instruction_CreateNativeMint = ag_binary.TypeID([8]byte{114, 254, 53, 96, 51, 248, 117, 109})

	Instruction_InitializeNonTransferableMint = ag_binary.TypeID([8]byte{242, 68, 44, 126, 194, 231, 206, 200})

	Instruction_InitializePermanentDelegate = ag_binary.TypeID([8]byte{98, 200, 9, 70, 17, 203, 130, 60})
)

// InstructionIDToName returns the name of the instruction given its ID.
func InstructionIDToName(id ag_binary.TypeID) string {
	switch id {
	case Instruction_InitializeMint:
		return "InitializeMint"
	case Instruction_InitializeAccount:
		return "InitializeAccount"
	case Instruction_InitializeMultisig:
		return "InitializeMultisig"
	case Instruction_Transfer:
		return "Transfer"
	case Instruction_Approve:
		return "Approve"
	case Instruction_Revoke:
		return "Revoke"
	case Instruction_SetAuthority:
		return "SetAuthority"
	case Instruction_MintTo:
		return "MintTo"
	case Instruction_Burn:
		return "Burn"
	case Instruction_CloseAccount:
		return "CloseAccount"
	case Instruction_FreezeAccount:
		return "FreezeAccount"
	case Instruction_ThawAccount:
		return "ThawAccount"
	case Instruction_TransferChecked:
		return "TransferChecked"
	case Instruction_ApproveChecked:
		return "ApproveChecked"
	case Instruction_MintToChecked:
		return "MintToChecked"
	case Instruction_BurnChecked:
		return "BurnChecked"
	case Instruction_InitializeAccount2:
		return "InitializeAccount2"
	case Instruction_SyncNative:
		return "SyncNative"
	case Instruction_InitializeAccount3:
		return "InitializeAccount3"
	case Instruction_InitializeMultisig2:
		return "InitializeMultisig2"
	case Instruction_InitializeMint2:
		return "InitializeMint2"
	case Instruction_GetAccountDataSize:
		return "GetAccountDataSize"
	case Instruction_InitializeImmutableOwner:
		return "InitializeImmutableOwner"
	case Instruction_AmountToUiAmount:
		return "AmountToUiAmount"
	case Instruction_UiAmountToAmount:
		return "UiAmountToAmount"
	case Instruction_InitializeMintCloseAuthority:
		return "InitializeMintCloseAuthority"
	case Instruction_Reallocate:
		return "Reallocate"
	case Instruction_CreateNativeMint:
		return "CreateNativeMint"
	case Instruction_InitializeNonTransferableMint:
		return "InitializeNonTransferableMint"
	case Instruction_InitializePermanentDelegate:
		return "InitializePermanentDelegate"
	default:
		return ""
	}
}

type Instruction struct {
	ag_binary.BaseVariant
}

func (inst *Instruction) EncodeToTree(parent ag_treeout.Branches) {
	if enToTree, ok := inst.Impl.(ag_text.EncodableToTree); ok {
		enToTree.EncodeToTree(parent)
	} else {
		parent.Child(ag_spew.Sdump(inst))
	}
}

var InstructionImplDef = ag_binary.NewVariantDefinition(
	ag_binary.AnchorTypeIDEncoding,
	[]ag_binary.VariantType{
		{
			"initialize_mint", (*InitializeMint)(nil),
		},
		{
			"initialize_account", (*InitializeAccount)(nil),
		},
		{
			"initialize_multisig", (*InitializeMultisig)(nil),
		},
		{
			"transfer", (*Transfer)(nil),
		},
		{
			"approve", (*Approve)(nil),
		},
		{
			"revoke", (*Revoke)(nil),
		},
		{
			"set_authority", (*SetAuthority)(nil),
		},
		{
			"mint_to", (*MintTo)(nil),
		},
		{
			"burn", (*Burn)(nil),
		},
		{
			"close_account", (*CloseAccount)(nil),
		},
		{
			"freeze_account", (*FreezeAccount)(nil),
		},
		{
			"thaw_account", (*ThawAccount)(nil),
		},
		{
			"transfer_checked", (*TransferChecked)(nil),
		},
		{
			"approve_checked", (*ApproveChecked)(nil),
		},
		{
			"mint_to_checked", (*MintToChecked)(nil),
		},
		{
			"burn_checked", (*BurnChecked)(nil),
		},
		{
			"initialize_account2", (*InitializeAccount2)(nil),
		},
		{
			"sync_native", (*SyncNative)(nil),
		},
		{
			"initialize_account3", (*InitializeAccount3)(nil),
		},
		{
			"initialize_multisig2", (*InitializeMultisig2)(nil),
		},
		{
			"initialize_mint2", (*InitializeMint2)(nil),
		},
		{
			"get_account_data_size", (*GetAccountDataSize)(nil),
		},
		{
			"initialize_immutable_owner", (*InitializeImmutableOwner)(nil),
		},
		{
			"amount_to_ui_amount", (*AmountToUiAmount)(nil),
		},
		{
			"ui_amount_to_amount", (*UiAmountToAmount)(nil),
		},
		{
			"initialize_mint_close_authority", (*InitializeMintCloseAuthority)(nil),
		},
		{
			"reallocate", (*Reallocate)(nil),
		},
		{
			"create_native_mint", (*CreateNativeMint)(nil),
		},
		{
			"initialize_non_transferable_mint", (*InitializeNonTransferableMint)(nil),
		},
		{
			"initialize_permanent_delegate", (*InitializePermanentDelegate)(nil),
		},
	},
)

func (inst *Instruction) ProgramID() ag_solanago.PublicKey {
	return ProgramID
}

func (inst *Instruction) Accounts() (out []*ag_solanago.AccountMeta) {
	return inst.Impl.(ag_solanago.AccountsGettable).GetAccounts()
}

func (inst *Instruction) Data() ([]byte, error) {
	buf := new(bytes.Buffer)
	if err := ag_binary.NewBorshEncoder(buf).Encode(inst); err != nil {
		return nil, fmt.Errorf("unable to encode instruction: %w", err)
	}
	return buf.Bytes(), nil
}

func (inst *Instruction) TextEncode(encoder *ag_text.Encoder, option *ag_text.Option) error {
	return encoder.Encode(inst.Impl, option)
}

func (inst *Instruction) UnmarshalWithDecoder(decoder *ag_binary.Decoder) error {
	return inst.BaseVariant.UnmarshalBinaryVariant(decoder, InstructionImplDef)
}

func (inst *Instruction) MarshalWithEncoder(encoder *ag_binary.Encoder) error {
	err := encoder.WriteBytes(inst.TypeID.Bytes(), false)
	if err != nil {
		return fmt.Errorf("unable to write variant type: %w", err)
	}
	return encoder.Encode(inst.Impl)
}

func registryDecodeInstruction(accounts []*ag_solanago.AccountMeta, data []byte) (interface{}, error) {
	inst, err := DecodeInstruction(accounts, data)
	if err != nil {
		return nil, err
	}
	return inst, nil
}

func DecodeInstruction(accounts []*ag_solanago.AccountMeta, data []byte) (*Instruction, error) {
	inst := new(Instruction)
	if err := ag_binary.NewBorshDecoder(data).Decode(inst); err != nil {
		return nil, fmt.Errorf("unable to decode instruction: %w", err)
	}
	if v, ok := inst.Impl.(ag_solanago.AccountsSettable); ok {
		err := v.SetAccounts(accounts)
		if err != nil {
			return nil, fmt.Errorf("unable to set accounts for instruction: %w", err)
		}
	}
	return inst, nil
}

## rc_dex微服务搭建步骤
1. 在`rc_dex`目录下执行`go mod init module-name`,生成`go.mod`文件
2. 创建网关：执行`goctl gateway --dir gateway`
    ```
    gateway/
    ├── etc/                 # 配置文件目录
    │   ├── gateway.yaml     # 服务配置文件
    │── main.go              # 服务主入口，服务启动文件，使用它将服务启动起来
    ```
3. 创建一个微服务模块，使用`goctl rpc new`命令：

   `goctl rpc new consumer`: `consumer `模块，用来消费helius的数据
4. 执行`go run consumer.go`
    ```
    MacBook-Pro:consumer ~$ go run consumer.go
    Starting rpc server at 0.0.0.0:8080...
    ```
5. 安装bloomRPC，基础的客户端测试工具（https://github.com/bloomrpc/bloomrpc/releases）

    导入`consumer.proto`文件

    修改端口为`127.0.0.1:8080`，与上面的端口保持一致

    点击运行，返回：
    ```
    {
    "pong": ""
    }
    ```
    `/ping`的实现逻辑在`./internal/logic/pinglogic.go`，修改为：
    ```go
    return &consumer.Response{Pong: "hello world of logic layer"}, nil
    ```
    （由于没有热部署）ctrl+C关掉服务，再启动，再点击运行，返回：
    ```
    {
    "pong": "hello world of logic layer"
    }
    ```

## gRPC微服务调用
[gRPC gateway 官网介绍](https://go-zero.dev/docs/tutorials/gateway/grpc)

前面是基于proto文件进行的RPC的方式调用，并没有网关的参与，现在希望通过http请求或者浏览器访问或者curl请求到，完整流程：
```
   (HTTP请求)
前端  -->  网关  -->  RPC服务 -->  后端proto
```

### 步骤：
1. 新建proto文件`hello_server.proto`

2. 执行如下指令生成 protoDescriptor：
    ```bash
    $ protoc --descriptor_set_out=gateway/hello_server.pb hello_server.proto
    ```
    在`gateway`目录下生成了`hello_server.pb`的二进制文件

3. 执行如下指令，基于proto文件生成gRPC服务代码：
   相当于基于proto文件生成了一个新服务出来（跟consumer一样的服务）
    ```bash
    # hello_server是生成的文件存放的文件目录
    $ goctl rpc protoc hello_server.proto --go_out=hello_server --go-grpc_out=hello_server --zrpc_out=hello_server
    ```

4. 到`hello-server`文件夹下将hello服务运行起来
    ```bash
    MacBook-Pro:rc_dex ~$ cd hello_server
    MacBook-Pro:hello_server ~$ go run helloserver.go 
    Starting rpc server at 0.0.0.0:8080...
    ```
5. 进入`gateway/etc/gateway.yaml`，将mapping映射打开：
    ```bash
    ProtoSets:
      - hello_server.pb # 修改为hello_server.pb
    # Mappings can also be written in proto options
    Mappings: # routes mapping
      - Method: get
        Path: /ping  # 通过请求gateway_host:gateway_port/ping，网关会将请求映射到RpcPath上
        RpcPath: hello.Hello/Ping # 这里映射的是hello_server.proto文件中的包名hello+service Hello中的Ping方法（第5、20、22行）
    ```
6. 新建终端窗口，将gateway服务运行起来
    ```bash
    MacBook-Pro:gateway ~$ go run main.go
    {"@timestamp":"2025-11-15T20:32:25.020+08:00","caller":"stat/usage.go:82","content":"CPU: 0m, MEMORY: Alloc=2.5Mi, TotalAlloc=4.3Mi, Sys=13.6Mi, NumGC=2","level":"stat"}
    {"@timestamp":"2025-11-15T20:32:25.030+08:00","caller":"load/sheddingstat.go:61","content":"(api) shedding_stat [1m], cpu: 0, total: 0, pass: 0, drop: 0","level":"stat"}
    ```
7. 再新建终端窗口执行curl命令
    ```bash
    MacBook-Pro:dex_amm ~$ curl http://localhost:8888/ping
    
    {"msg":"hello server of logic layer"}
    ```

以上，说明通过http请求实现了微服务的访问。

# 项目部分
## 0x1 实时获取最新区块
### 1. 对接helius，[官方文档](https://www.helius.dev/docs/zh/api-reference)
- `consumer.yaml`:
    ```yaml
    # 增加 Solana 区块链配置，映射到config.go中的Chain结构体
    Sol:
        ChainId: 100000
        # RPC 节点 URL 列表，用于 HTTP 请求
        NodeUrl:
            - "https://devnet.helius-rpc.com/?api-key=ffb452cc-5d85-4d2c-b3b1-2fc808745116"
        # WebSocket URL，用于实时订阅和监听
        WSUrl: "wss://devnet.helius-rpc.com/?api-key=ffb452cc-5d85-4d2c-b3b1-2fc808745116"
    ```
- `config.go`:
    ```go
    type Chain struct {
        ChainId    int64    `json:"ChainId" env:"SOL_CHAINID"`
        NodeUrl    []string `json:"NodeUrl" env:"SOL_NODEURL"`
        WSUrl      string   `json:"WSUrl,optional" env:"SOL_WSURL"`
        MEVNodeUrl string   `json:"MevNodeUrl,optional" env:"SOL_MEVNODEURL"`
        StartBlock uint64   `json:"StartBlock,optional" env:"SOL_STARTBLOCK"`
    }
    ```

    > #### <font color="red">语法说明:</font>
    > Go 结构体标签语法规则：
    > 1. 整个标签用反引号 `` 包围 
    > 2. 多个标签键值对用空格分隔 
    > 3. 格式：`key1:"value1" key2:"value2" `
    > 4. 每个键只能出现一次
    > 
    > **含义：** 
    > - `json:"ChainId"`：YAML字段匹配，JSON 序列化/反序列化时使用字段名 "ChainId" 
    > - `env:"SOL_CHAINID"`：用于环境变量覆盖（go-zero 配置系统支持），如果设置了环境变量SOL_CHAINID，会覆盖YAML中的值

### 2. 解析slot

    `consumer/internal/logic`下新增`slot`文件夹，用来放解析slot的文件
    ```
    rc_dex/
    ├── consumer/                 
    │   ├── internal/
    |      ├── logic/
    |         ├── slot/              # 
    │            ├── group.go        # 
    │            ├── slot.go         # 
    │            └── websocket.go    # 
    ```

### 3. 运行
```bash
go run consumer.go

(控制台出现SlotId的不断打印)
```

> #### <font color="red">语法说明:</font>
> ### 依赖注入
> 服务上下文ServiceContext的使用是依赖注入的方式
> 
> 依赖注入 = 通过参数传递依赖
> 
> 核心思想：谁需要依赖，谁就通过参数接收，而不是自己创建
>
> 好处：解耦、可测试、易扩展

## 0x2 go-routine生产消费链上数据
生产者： 创建channel，作为参数传递到SlotService，把读到的slot数据写进channel

## 0x3 通过slot获取区块数据
直接调用solana client接口GetBlockWithConfig

## 0x4 区块交易与指令过滤
逻辑简单，***<font color="red">重要的是对链上数据的熟悉度，比如账户结构 todo</font>***

## 0x5 交易指令与参数解析
***<font color="red">参考GMGN学习如何对数据进行索引和利用 todo</font>***

## 0x5 保存区块数据
生成 model crud 代码
```bash
goctl model mysql ddl --src=model/sql/sol.sql --dir=model/solmodel --home template
```